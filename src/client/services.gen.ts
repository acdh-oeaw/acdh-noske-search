// This file is auto-generated by @hey-api/openapi-ts

import type { CancelablePromise } from './core/CancelablePromise';
import { OpenAPI } from './core/OpenAPI';
import { request as __request } from './core/request';
import type { GetCorpInfoData, GetCorpInfoResponse, GetWordListData, GetWordListResponse, GetStructWordListData, GetStructWordListResponse, GetConcordanceData, GetConcordanceResponse, GetFullRefData, GetFullRefResponse, GetWideCtxData, GetWideCtxResponse, GetFreqMlData, GetFreqMlResponse, GetFregDistribData, GetFregDistribResponse, GetFreqDistData, GetFreqDistResponse, GetCollxData, GetCollxResponse, GetSubCorpData, GetSubCorpResponse, SubcorpusRenameData, SubcorpusRenameResponse, SubcorpusInfoData, SubcorpusInfoResponse, GetExtractKeywordsData, GetExtractKeywordsResponse, GetTextTypesWithNormsData, GetTextTypesWithNormsResponse, GetAttrValsData, GetAttrValsResponse, GetCorporaResponse, CreateCorpusData, CreateCorpusResponse, GetCorpusData, GetCorpusResponse, UpdateCorpusData, UpdateCorpusResponse, DeleteCorpusData, DeleteCorpusResponse, CheckCompilableData, CheckCompilableResponse, GetCompilationProgressData, GetCompilationProgressResponse, CompileCorpusData, CompileCorpusResponse, GetCompilationLogData, GetCompilationLogResponse, GetCorpusSourceData, GetCorpusSourceResponse, CancelJobData, CancelJobResponse, CompileAlignedCorpusData, CompileAlignedCorpusResponse, SegmentAlignData, SegmentAlignResponse, GetAllDocumentsData, GetAllDocumentsResponse, CreateNewDocumentData, CreateNewDocumentResponse, UpdateDocumentMetadataData, UpdateDocumentMetadataResponse, GetDocumentData, GetDocumentResponse, UpdateDocumentData, UpdateDocumentResponse, DeleteDocumentsData, DeleteDocumentsResponse, UpdateDocumentParametersData, UpdateDocumentParametersResponse, GetDocumentOriginalData, GetDocumentOriginalResponse, GetDocumentPlaintextData, GetDocumentPlaintextResponse, GetDocumentVerticalData, GetDocumentVerticalResponse, ExpandArchiveData, ExpandArchiveResponse, CancelDocumentJobData, CancelDocumentJobResponse, GetProgressData, GetProgressResponse, GetFileSetsData, GetFileSetsResponse, CreateFileSetData, CreateFileSetResponse, GetFileSetData, GetFileSetResponse, DeleteFileSetData, DeleteFileSetResponse, CancelFileSetJobData, CancelFileSetJobResponse, GetFileSetProgressData, GetFileSetProgressResponse, GetLanguagesResponse, UploadAligendDocumentsData, UploadAligendDocumentsResponse, GetAlignedDocumentsData, GetAlignedDocumentsResponse, UpdateAlignedDocsData, UpdateAlignedDocsResponse, GetUserTemplateData, GetUserTemplateResponse, UpdateUserTemplateData, UpdateUserTemplateResponse, DeleteUserTemplateData, DeleteUserTemplateResponse, GetUsedSpaceData, GetUsedSpaceResponse } from './types.gen';

export class CorpusSearchService {
    /**
     * Statistics and information about the whole corpus.
     * -
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.usesubcorp The name of the `subcorpus`. The `default` value `empty string` refers to the entire corpus. An example for `preloaded/bnc2_tt21` can be `Written Academic` or `1960-1974`.
     * @param data.subcorpora A parameter to obtain the list of subcorpora and their sizes (e.g. number of tokens, words).
     * @param data.gramrels A list of grammatical relations from the correspoding `sketch grammar`.
     * @param data.corpcheck Results of the last corpcheck (if available in the compilation log).
     * @param data.registry The content of the registry file (registry_dump and registry_text).
     * @param data.structAttrStats The lexicon sizes of structure attributes.
     * @param data.format The `format` of the output. `Empty value` is interpreted as `JSON`. Not every endpoint supports all formats.
     * @returns _corp_info `OK`
     * @throws ApiError
     */
    public static getCorpInfo(data: GetCorpInfoData): CancelablePromise<GetCorpInfoResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/corp_info',
            query: {
                corpname: data.corpname,
                usesubcorp: data.usesubcorp,
                subcorpora: data.subcorpora,
                gramrels: data.gramrels,
                corpcheck: data.corpcheck,
                registry: data.registry,
                struct_attr_stats: data.structAttrStats,
                format: data.format
            }
        });
    }
    
    /**
     * A list of word frequencies from the specified corpus.
     * This method can be used for generating frequency lists of all tokens, lemmas, word forms etc. or for retrieving frequencies of concrete items. Regex can be used for detailed criteria.
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.wlattr Sets the corpus attribute you want to work with. Some corpora may have specific additional attributes.
     *
     * Basic examples:
     * - word
     * - lc
     * - lemma
     * - lemma_lc
     * - lempos
     * - lempos_lc
     * - tag
     * - pos
     *
     * For list of available word list attributes see **ca/api/corpora/{corpusId}**
     * @param data.usesubcorp The name of the `subcorpus`. The `default` value `empty string` refers to the entire corpus. An example for `preloaded/bnc2_tt21` can be `Written Academic` or `1960-1974`.
     * @param data.wlnums The type of frequency. The values stand for: `frq` -> absolute or raw frequency, `docf` -> document frequency. `arf` -> average reduced frequency.
     * @param data.wlmaxfreq Sets the maximum frequency limit in the wordlist.
     * @param data.wlminfreq Sets the minimum frequency limit. Items with a lower frequency will not be included.
     * @param data.wlpat Sets a regex to filter the results. Relevant only in a simple wordlist.
     * @param data.wlsort Sets the sorting of the results. The default is `frq`, i.e. by absolute frequency. Docf means document frequency.
     * @param data.wlblacklist A deny list (formerly known as blacklist) is a list of items that should be excluded from the result. The values should be be separated by a newline symbol (without commas between values). In the URL, the newline symbol is `
    `.
     * @param data.includeNonwords Includes, or excludes, nonwords in the in the result. Nonwords are tokens which do not start with letter of the alphabet (e.g. numbers, punctuation). The regex to match the nonwords is `[^[:alpha:]].*`. Certain specialized corpora may use their own specific definition of nonwords.
     * @param data.relfreq Includes the relative frequency of each item in the result.
     * @param data.reldocf Calculate the document frequency for each item in the result. Must be used with `addfreqs` set to `docf`.
     * @param data.wlfile Defines the allow list (formerly known as whitelist), the list of words which should be included in the list. See also `wlblacklist`.
     * @param data.wlicase Sets the case sensitivity of the corpus, i.e. the data are extracted from a lowercased version of the corpus. It is used for case insensitive analysis. Parameter "1" means case sensitivity, "0" means case insensitivity.
     * @param data.wlmaxitems Sets the number of items to be returned in the API response. It is not limited for user corpora, in preloaded corpora can be some limitation. This parameter is often used with wlpage to help with pagination in frontend development.
     * @param data.wlpage To select page of the response. The number of items on the page is specified by parameter wlmaxitems.
     * @param data.format The `format` of the output. `Empty value` is interpreted as `JSON`. Not every endpoint supports all formats.
     * @param data.random Parameter that represents if the wordlist is created from the first 10 milions lines of corpus. One if yes, no if he wordlist is created from the whole corpus.
     * @param data.wltype Parameter to set the format of ouput. Is it always set to `simple`, for the `struct_wordlist` is another enpoint called `struct_wordlist`.
     * @param data.ngramsN The minimum n-gram length. Usually used with `ngrams_max_n` and `usengrams`.
     * @param data.ngramsMaxN The maximum n-gram length. The maximum is `6`.
     * @param data.nestNgrams N-grams which are sub-ngrams of a longer n-gram will be grouped together with the longer n-gram. Nesting only works when a `ngrams_n` and `ngrams_max_n` are different values.
     * @param data.simpleN The smoothing parameter for (simple maths) [https://www.sketchengine.eu/documentation/simple-maths/].
     * @param data.usengrams Represent if n-grams should be extracted or just simple keywords.
     * @returns _wordlist `OK`
     * @throws ApiError
     */
    public static getWordList(data: GetWordListData): CancelablePromise<GetWordListResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/wordlist',
            query: {
                corpname: data.corpname,
                wlattr: data.wlattr,
                usesubcorp: data.usesubcorp,
                wlnums: data.wlnums,
                wlmaxfreq: data.wlmaxfreq,
                wlminfreq: data.wlminfreq,
                wlpat: data.wlpat,
                wlsort: data.wlsort,
                wlblacklist: data.wlblacklist,
                include_nonwords: data.includeNonwords,
                relfreq: data.relfreq,
                reldocf: data.reldocf,
                wlfile: data.wlfile,
                wlicase: data.wlicase,
                wlmaxitems: data.wlmaxitems,
                wlpage: data.wlpage,
                format: data.format,
                random: data.random,
                wltype: data.wltype,
                ngrams_n: data.ngramsN,
                ngrams_max_n: data.ngramsMaxN,
                nest_ngrams: data.nestNgrams,
                simple_n: data.simpleN,
                usengrams: data.usengrams
            }
        });
    }
    
    /**
     * Provides a list of frequencies in the specified corpus. Offers more flexibility.
     * The difference from the wordlist is that this enpoint allows to customize how the results are displayed.
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.wlattr Sets the corpus attribute you want to work with. Some corpora may have specific additional attributes.
     *
     * Basic examples:
     * - word
     * - lc
     * - lemma
     * - lemma_lc
     * - lempos
     * - lempos_lc
     * - tag
     * - pos
     *
     * For list of available word list attributes see **ca/api/corpora/{corpusId}**
     * @param data.wlstructAttr1 Sets the attributes used for generating the wordlist. Up to 3 attributes are allowed (see wlstruct_attr2 and wlstruct_attr3). Some corpora may contain additional specific attributes.
     * @param data.wlstructAttr2 Additional optional attribute that should be included in the result.
     * @param data.wlstructAttr3 Additional optional attribute that should be included in the result.
     * @param data.wlnums The type of frequency. The values stand for: `frq` -> absolute or raw frequency, `docf` -> document frequency. `arf` -> average reduced frequency.
     * @param data.wlmaxfreq Sets the maximum frequency limit in the wordlist.
     * @param data.wlminfreq Sets the minimum frequency limit. Items with a lower frequency will not be included.
     * @param data.wlmaxitems Sets the number of items to be returned in the API response. It is not limited for user corpora, in preloaded corpora can be some limitation. This parameter is often used with wlpage to help with pagination in frontend development.
     * @param data.wlpat Sets a regex to filter the results. Relevant only in a simple wordlist.
     * @param data.wlsort Sets the sorting of the results. The default is `frq`, i.e. by absolute frequency. Docf means document frequency.
     * @param data.wlblacklist A deny list (formerly known as blacklist) is a list of items that should be excluded from the result. The values should be be separated by a newline symbol (without commas between values). In the URL, the newline symbol is `
    `.
     * @param data.includeNonwords Includes, or excludes, nonwords in the in the result. Nonwords are tokens which do not start with letter of the alphabet (e.g. numbers, punctuation). The regex to match the nonwords is `[^[:alpha:]].*`. Certain specialized corpora may use their own specific definition of nonwords.
     * @param data.relfreq Includes the relative frequency of each item in the result.
     * @param data.reldocf Calculate the document frequency for each item in the result. Must be used with `addfreqs` set to `docf`.
     * @param data.wlicase Sets the case sensitivity of the corpus, i.e. the data are extracted from a lowercased version of the corpus. It is used for case insensitive analysis. Parameter "1" means case sensitivity, "0" means case insensitivity.
     * @param data.wlpage To select page of the response. The number of items on the page is specified by parameter wlmaxitems.
     * @param data.format The `format` of the output. `Empty value` is interpreted as `JSON`. Not every endpoint supports all formats.
     * @param data.random Parameter that represents if the wordlist is created from the first 10 milions lines of corpus. One if yes, no if he wordlist is created from the whole corpus.
     * @param data.wltype Parameter to set the format of ouput. Is it always set to `simple`, for the `struct_wordlist` is another enpoint called `struct_wordlist`.
     * @returns _struct_wordlist `OK`
     * @throws ApiError
     */
    public static getStructWordList(data: GetStructWordListData): CancelablePromise<GetStructWordListResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/struct_wordlist',
            query: {
                corpname: data.corpname,
                wlattr: data.wlattr,
                wlstruct_attr1: data.wlstructAttr1,
                wlstruct_attr2: data.wlstructAttr2,
                wlstruct_attr3: data.wlstructAttr3,
                wlnums: data.wlnums,
                wlmaxfreq: data.wlmaxfreq,
                wlminfreq: data.wlminfreq,
                wlmaxitems: data.wlmaxitems,
                wlpat: data.wlpat,
                wlsort: data.wlsort,
                wlblacklist: data.wlblacklist,
                include_nonwords: data.includeNonwords,
                relfreq: data.relfreq,
                reldocf: data.reldocf,
                wlicase: data.wlicase,
                wlpage: data.wlpage,
                format: data.format,
                random: data.random,
                wltype: data.wltype
            }
        });
    }
    
    /**
     * Concordance - shows the search word or phrase in context.
     * The concordance allows complex criteria for searching the corpus. The queries can combine any data, metadata and annotations found in the corpus.
     *
     * `To make basic concordance its enough to use just corpname and q parameters.`
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.q The CQL query. Regexes are supported for `lemma`, `phrase` and `word` types. The `iquery` supports simplified wildcards (see concordance_query[iquery]). If you decide to use the concordance_query in a json parameter, you do not have to use this parameter.
     * @param data.concordanceQueryQueryselector The query type. You can send it directly or via the `json` parameter, the results are the same.
     * @param data.concordanceQueryIquery Only works when `queryselector` is set to `iqueryrow`. Type a word or phrase.
     *
     * These special wildcards are supported .
     *
     * Use the `asterisk (*)` for any number of unspecified characters. Use a `question mark (?)` for exactly one unspecified character. Use the `pipe (|)` to include more than one word or phrase. Use `two hyphens (--)` to find a word which is  hyphenated, non-hyphenated or spelt as two separate words.
     * @param data.concordanceQueryCql Only works when `queryselector` is set to `cqlrow`. Type the query using the [cql](https://www.sketchengine.eu/documentation/corpus-querying/) query language.
     * @param data.concordanceQueryLemma Only works when `queryselector` is set to `lemmarow`. Type the lemma. Regex is supported.
     * @param data.concordanceQueryChar Only works when `queryselector` is set to `charrow`. Type the characters that the tokens should contain. Regex is supported.
     * @param data.concordanceQueryWord Only works when `queryselector` is set to `wordrow`. Type the word form. Regex is supported.
     * @param data.concordanceQueryPhrase Only works when `queryselector` is set to `phraserow`. Type the phrase. Regex is supported.
     * @param data.usesubcorp The name of the `subcorpus`. The `default` value `empty string` refers to the entire corpus. An example for `preloaded/bnc2_tt21` can be `Written Academic` or `1960-1974`.
     * @param data.lpos The part of speech of the lemma. The concrete values depend on the corpus. If the corpus contains the `lempos` attribute and `lpos` is empty, the result defaults to the most frequent part of speech of the lemma.
     * @param data.defaultAttr The attribute applied to tokens in the query which do not have an attribute specified explicitly as part of the query.
     * @param data.attrs A list of comma-delimited attributes that are returned together with each token. Other examples are:`word, lc, lemma, tag` etc..
     * @param data.refs The text type (metadata) for which statistics should be calculated from the concordance. The default is `bncdoc.alltyp` (all available text types are included). Text types (attributes and there values) differ between corpora). You can find them in the response of `corpus_info` method in `freqttattrs` or `subcorpattrs` keys. Not all of them have attributes to show.
     * @param data.attrAllpos Determines which tokens will be returned with additional attributes defined in `attrs`. `kw` will add the attributes to the KWIC only. `all` will return them with all tokens.
     * @param data.viewmode Switches between sentence view and the KWIC view. `sen` returns complete sentences without trimming them. `kwic` returns the KWIC view with the query in the centre and some context left and right.
     * @param data.cupHl Only used with error-annotated corpora. It determines what should be highlighted. It is set to 'q' for corpora without error annotation. Meaning of individual options:
     *
     * - `q` -> to higlight query result.
     *
     * - `e` -> to higlight errors.
     *
     * - `c` -> to highlight corrections.
     *
     * - `b` -> to highlight both erros and corrections.
     *
     * Example of such a corpus can be `preloaded/enwiki_error_sample_sentences`.
     * @param data.structs A list of comma-delimited structures (=structure tags) that should be included in the result.
     * @param data.fromp The number of the page that should be returned.
     * @param data.pagesize The number of lines in the concordance.
     * @param data.kwicleftctx The size of the left context in KWIC view. Number of tokens.
     * @param data.kwicrightctx The size of the right context in KWIC view. Number of tokens.
     * @param data.errcorrSwitch (Only for error-annotated corpora.) Determines what should be highlighted. Corr means **correction** and err means **error**. An **example** of such a corpus is `preloaded/enwiki_error_sample_sentences`.
     * @param data.cupErrCode (Only for error-annotated corpora). Determines which error type to higlight. An example of such a corpus is `preloaded/enwiki_error_sample_sentences`.
     * @param data.cupErr (Only for error-annotated corpora.) An error token to search.
     * @param data.cupCorr (Only for error-annotated corpora.) A correction token to search.
     * @param data.json An optinal way of **wraping parameters**. It is possible to send all parametres via this parameter only.
     *
     * The most frequent uses are:
     *
     * `queryselector`: To select the query type. Supported options are: **cqlrow**, **iqueryrow**, **lemmarow**, **charrow**, **phraserow**, **wordrow**. For more information see concordance_query parameters.
     *
     * `iquery`: Use with `iqueryrow`.
     *
     * `cql`: Use with `cqlrow`.
     *
     * `lemma`: Use with `lemmarow`.
     *
     * `lpos`: The part of speech of the lemma.
     *
     * `qmcase`: Sets the attribute to its lowercased version, i.e. the data are extracted from a lowercased version of the corpus. It used for case insensitive analysis. 1 = case sensitive), 0 = lowercased corpus/case insensitive).
     *
     *
     * `char`: Use with charrow.
     *
     * `phrase`: Use with phraserow.
     *
     * `word`: Use with wordrow
     *
     *
     * `name`:
     *
     * `pnfilter`:
     *
     * `inclkwic`:
     *
     * `filfpos`:
     *
     * `filtpos`:
     *
     * `desc`:
     *
     * `q`:
     *
     *
     * @param data.asyn Switches the asynchronous processing on/off. ON = partial results are returned as soon as the first page is filled with results. OFF = results are returned only after the search is completed. Normally, ON is used in the web interface and OFF when using the API.
     * @param data.format The `format` of the output. `Empty value` is interpreted as `JSON`. Not every endpoint supports all formats.
     * @returns _concordance `OK`
     * @throws ApiError
     */
    public static getConcordance(data: GetConcordanceData): CancelablePromise<GetConcordanceResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/concordance',
            query: {
                corpname: data.corpname,
                q: data.q,
                'concordance_query[queryselector]': data.concordanceQueryQueryselector,
                'concordance_query[iquery]': data.concordanceQueryIquery,
                'concordance_query[cql]': data.concordanceQueryCql,
                'concordance_query[lemma]': data.concordanceQueryLemma,
                'concordance_query[char]': data.concordanceQueryChar,
                'concordance_query[word]': data.concordanceQueryWord,
                'concordance_query[phrase]': data.concordanceQueryPhrase,
                usesubcorp: data.usesubcorp,
                lpos: data.lpos,
                default_attr: data.defaultAttr,
                attrs: data.attrs,
                refs: data.refs,
                attr_allpos: data.attrAllpos,
                viewmode: data.viewmode,
                cup_hl: data.cupHl,
                structs: data.structs,
                fromp: data.fromp,
                pagesize: data.pagesize,
                kwicleftctx: data.kwicleftctx,
                kwicrightctx: data.kwicrightctx,
                errcorr_switch: data.errcorrSwitch,
                cup_err_code: data.cupErrCode,
                cup_err: data.cupErr,
                cup_corr: data.cupCorr,
                json: data.json,
                asyn: data.asyn,
                format: data.format
            }
        });
    }
    
    /**
     * Returns all metadata of one concordance line.
     * Displays all available text types (metadata) related to the concrete KWIC (hit) defined by its position in the corpus.
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.pos The position of the first token of KWIC in the corpus.
     * @returns _fullref `OK`
     * @throws ApiError
     */
    public static getFullRef(data: GetFullRefData): CancelablePromise<GetFullRefResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/fullref',
            query: {
                corpname: data.corpname,
                pos: data.pos
            }
        });
    }
    
    /**
     * Returns extended context the KWIC in a concrete concordance line.
     * This is the equivalent of clicking KWIC in one concordance line which displays a popup with an extended context.
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.pos The position of the first token of KWIC in the corpus.
     * @param data.hitlen Only used by the web interface. Indicates the number of tokens that should be highlighted in red.
     * @param data.structs A list of comma-delimited structures (=structure tags) that should be included in the result.
     * @param data.detailLeftCtx Size of the left context in tokens.
     * @param data.detailRightCtx Size of the right context in tokens.
     * @returns _widectx `OK`
     * @throws ApiError
     */
    public static getWideCtx(data: GetWideCtxData): CancelablePromise<GetWideCtxResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/widectx',
            query: {
                corpname: data.corpname,
                pos: data.pos,
                hitlen: data.hitlen,
                structs: data.structs,
                detail_left_ctx: data.detailLeftCtx,
                detail_right_ctx: data.detailRightCtx
            }
        });
    }
    
    /**
     * Calculates frequencies of words, lemmas… in the concordance.
     * The frequency of any [positional attribute] (https://www.sketchengine.eu/my_keywords/positional-attribute/) such as word forms, lemmas, tags can be counted with this method. Structure attributes (metadata/text types) can also be counted.
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.ml1Attr Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/) or structure attributes (metadata/text types) of any token in the concordance.\n\n A maximum of 6 attributes is allowed (e.g. ml2attr, ml3attr). At least one attribute is required.
     * @param data.ml1Ctx  Position of the selected attribute in the concordance. **Minus** means **left** context (-1<0). **Plus** means **right** context (6>0). **At least one attribute is required, the others are optional.** Every attribute (ml1attr, ml2attr. etc.) needs it's **own** context position (e.g. if 3 attributes are selected three context position **needs to** be set ml1ctx, ml2ctx, ml3ctx).
     *
     *
     * **Positions can be referenced as follows:**
     *
     * `integer number` - where **0** is the first token in **KWIC**, **-1** the rightmost token in the left context etc.
     *
     * `1:x` - where **x** is one of the corpus structures (e.g. “doc” or “s” if the corpus has the particular markup). Its meaning is the first token in the structure, except when it is the right boundary of a range - then it is the last token in the structure. Also, other numbers can be used, e.g. -2:x, 3:x, etc. (-1 is the same as 1 with meaning “structure containing KWIC”)
     *
     * `a<0` - where **a** stands for a position reference as described in the first two points with meaning '**a** positions before/after the firs KWIC position' (so this is equivalent to **a**)
     *
     * `a>0` - where **a** stands for the same position reference with meaning 'positions before/after the last KWIC position'
     *
     * in the previous two points, if **0** is substituted with a natural number **k**, it means 'before/after **k**-th collocation' instead of 'before/after KWIC'. Collocations are special token groups in the context, that can be added using positive filters (see below).
     *
     *
     * `Ranges` can be referenced as a~b where **a**, **b** stand for token identifiers as above. Examples of positions and ranges:
     *
     * `-1<0` - rightmost token in the left context
     *
     * `3>0` - third token in right context
     *
     * `0>0` - last token in KWIC
     *
     * `0<0` - first token in KWIC
     *
     * `0<0~0>0` - range of KWIC
     *
     * `-1<0~1>0` - range of KWIC with one token from the left context and one from the right context
     *
     * `1:s` - first token in the sentence containing KWIC (or its first token)
     *
     * `1:s>0` - first token in the sentence containing KWIC (or its last token)
     *
     * `0<1` - first token of the first-added collocation.
     *
     *
     * `Examples:`
     *
     * sword/ **1>0~3>0**
     *
     * sword/ **1>0~3>0**
     *
     * slemma/ **0<0~0>0**
     *
     * sword/i **-1**
     *
     * sword/ **0** word/ir **-1<0** tag/r **-2<0**
     *
     *
     * @param data.ml2Attr Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/). Just like `ml1attr` but optional.
     * @param data.ml2Ctx Position of the selected attribute in the concordance. Minus means left context (-1<0). Plus means right context (6>0). Just like ml1ctx but optional.
     * @param data.ml3Attr Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/). Just like `ml1attr` but optional.
     * @param data.ml3Ctx Position of the selected attribute in the concordance. Minus means left context (-1<0). Plus means right context (6>0). Just like ml1ctx but optional.
     * @param data.ml4Attr Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/). Just like `ml1attr` but optional.
     * @param data.ml4Ctx Position of the selected attribute in the concordance. Minus means left context (-1<0). Plus means right context (6>0). Just like ml1ctx but optional.
     * @param data.ml5Attr Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/). Just like `ml1attr` but optional.
     * @param data.ml5Ctx Position of the selected attribute in the concordance. Minus means left context (-1<0). Plus means right context (6>0). Just like ml1ctx but optional.
     * @param data.ml6Attr Used to count the frequency of positional attributes [attributes](https://www.sketchengine.eu/my_keywords/positional-attribute/). Just like `ml1attr` but optional.
     * @param data.ml6Ctx Position of the selected attribute in the concordance. Minus means left context (-1<0). Plus means right context (6>0). Just like ml1ctx but optional.
     * @param data.q The CQL query. Regexes are supported for `lemma`, `phrase` and `word` types. The `iquery` supports simplified wildcards (see concordance_query[iquery]). If you decide to use the concordance_query in a json parameter, you do not have to use this parameter.
     * @param data.usesubcorp The name of the `subcorpus`. The `default` value `empty string` refers to the entire corpus. An example for `preloaded/bnc2_tt21` can be `Written Academic` or `1960-1974`.
     * @param data.fmaxitems The number of items in one response.
     * @param data.fpage The number of the response batch (page). The number of items in each batch is specified by `fmaxitems`.
     * @param data.group If there are more attributes (e.g. m1attr, m2attr), the results can be grouped by the first column/attribute.
     * @param data.showpoc Includes the percentage of the concordance in the result.
     * @param data.showreltt Includes relative in text types value in the result.
     * @param data.showrel Includes the relative frequency in the result.
     * @param data.freqlevel The number of attributes for which the frequencies should be counted.
     * @param data.json An optinal way of **wraping parameters**. It is possible to send all parametres via this parameter only.
     *
     * The most frequent uses are:
     *
     * `queryselector`: To select the query type. Supported options are: **cqlrow**, **iqueryrow**, **lemmarow**, **charrow**, **phraserow**, **wordrow**. For more information see concordance_query parameters.
     *
     * `iquery`: Use with `iqueryrow`.
     *
     * `cql`: Use with `cqlrow`.
     *
     * `lemma`: Use with `lemmarow`.
     *
     * `lpos`: The part of speech of the lemma.
     *
     * `qmcase`: Sets the attribute to its lowercased version, i.e. the data are extracted from a lowercased version of the corpus. It used for case insensitive analysis. 1 = case sensitive), 0 = lowercased corpus/case insensitive).
     *
     *
     * `char`: Use with charrow.
     *
     * `phrase`: Use with phraserow.
     *
     * `word`: Use with wordrow
     *
     *
     * `name`:
     *
     * `pnfilter`:
     *
     * `inclkwic`:
     *
     * `filfpos`:
     *
     * `filtpos`:
     *
     * `desc`:
     *
     * `q`:
     *
     *
     * @param data.freqSort The identifier of the sorted column. Use `frq` (default) to sort by frequency.
     * @param data.format The `format` of the output. `Empty value` is interpreted as `JSON`. Not every endpoint supports all formats.
     * @returns _freqml `OK`
     * @throws ApiError
     */
    public static getFreqMl(data: GetFreqMlData): CancelablePromise<GetFreqMlResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/freqml',
            query: {
                corpname: data.corpname,
                ml1attr: data.ml1Attr,
                ml1ctx: data.ml1Ctx,
                ml2attr: data.ml2Attr,
                ml2ctx: data.ml2Ctx,
                ml3attr: data.ml3Attr,
                ml3ctx: data.ml3Ctx,
                ml4attr: data.ml4Attr,
                ml4ctx: data.ml4Ctx,
                ml5attr: data.ml5Attr,
                ml5ctx: data.ml5Ctx,
                ml6attr: data.ml6Attr,
                ml6ctx: data.ml6Ctx,
                q: data.q,
                usesubcorp: data.usesubcorp,
                fmaxitems: data.fmaxitems,
                fpage: data.fpage,
                group: data.group,
                showpoc: data.showpoc,
                showreltt: data.showreltt,
                showrel: data.showrel,
                freqlevel: data.freqlevel,
                json: data.json,
                freq_sort: data.freqSort,
                format: data.format
            }
        });
    }
    
    /**
     * Provides the distribution of hits in the corpus
     * -
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.res
     * @param data.lpos The part of speech of the lemma. The concrete values depend on the corpus. If the corpus contains the `lempos` attribute and `lpos` is empty, the result defaults to the most frequent part of speech of the lemma.
     * @param data.defaultAttr The attribute applied to tokens in the query which do not have an attribute specified explicitly as part of the query.
     * @param data.attrs A list of comma-delimited attributes that are returned together with each token. Other examples are:`word, lc, lemma, tag` etc..
     * @param data.structs A list of comma-delimited structures (=structure tags) that should be included in the result.
     * @param data.refs The text type (metadata) for which statistics should be calculated from the concordance. The default is `bncdoc.alltyp` (all available text types are included). Text types (attributes and there values) differ between corpora). You can find them in the response of `corpus_info` method in `freqttattrs` or `subcorpattrs` keys. Not all of them have attributes to show.
     * @param data.attrAllpos Determines which tokens will be returned with additional attributes defined in `attrs`. `kw` will add the attributes to the KWIC only. `all` will return them with all tokens.
     * @param data.viewmode Switches between sentence view and the KWIC view. `sen` returns complete sentences without trimming them. `kwic` returns the KWIC view with the query in the centre and some context left and right.
     * @param data.fcLemwordWindowType
     * @param data.fcLemwordWsize
     * @param data.fcLemwordType
     * @param data.fcPosWindowType
     * @param data.fcPosWsize
     * @param data.fcPosType
     * @param data.json An optinal way of **wraping parameters**. It is possible to send all parametres via this parameter only.
     *
     * The most frequent uses are:
     *
     * `queryselector`: To select the query type. Supported options are: **cqlrow**, **iqueryrow**, **lemmarow**, **charrow**, **phraserow**, **wordrow**. For more information see concordance_query parameters.
     *
     * `iquery`: Use with `iqueryrow`.
     *
     * `cql`: Use with `cqlrow`.
     *
     * `lemma`: Use with `lemmarow`.
     *
     * `lpos`: The part of speech of the lemma.
     *
     * `qmcase`: Sets the attribute to its lowercased version, i.e. the data are extracted from a lowercased version of the corpus. It used for case insensitive analysis. 1 = case sensitive), 0 = lowercased corpus/case insensitive).
     *
     *
     * `char`: Use with charrow.
     *
     * `phrase`: Use with phraserow.
     *
     * `word`: Use with wordrow
     *
     *
     * `name`:
     *
     * `pnfilter`:
     *
     * `inclkwic`:
     *
     * `filfpos`:
     *
     * `filtpos`:
     *
     * `desc`:
     *
     * `q`:
     *
     *
     * @param data.normalize
     * @param data.format The `format` of the output. `Empty value` is interpreted as `JSON`. Not every endpoint supports all formats.
     * @returns _freq_distrib `OK`
     * @throws ApiError
     */
    public static getFregDistrib(data: GetFregDistribData): CancelablePromise<GetFregDistribResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/freq_distrib',
            query: {
                corpname: data.corpname,
                res: data.res,
                lpos: data.lpos,
                default_attr: data.defaultAttr,
                attrs: data.attrs,
                structs: data.structs,
                refs: data.refs,
                attr_allpos: data.attrAllpos,
                viewmode: data.viewmode,
                fc_lemword_window_type: data.fcLemwordWindowType,
                fc_lemword_wsize: data.fcLemwordWsize,
                fc_lemword_type: data.fcLemwordType,
                fc_pos_window_type: data.fcPosWindowType,
                fc_pos_wsize: data.fcPosWsize,
                fc_pos_type: data.fcPosType,
                json: data.json,
                normalize: data.normalize,
                format: data.format
            }
        });
    }
    
    /**
     * Utility for web interface only. Provides relative frequency data for wordlist graphs within a specific time period, only for trend corpora.
     * -
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.wlattr Sets the corpus attribute you want to work with. Some corpora may have specific additional attributes.
     *
     * Basic examples:
     * - word
     * - lc
     * - lemma
     * - lemma_lc
     * - lempos
     * - lempos_lc
     * - tag
     * - pos
     *
     * For list of available word list attributes see **ca/api/corpora/{corpusId}**
     * @param data.diaattr A diachronic attribute to be selected. Available attributes **can differ** in corpora. Examples can be **doc.year** or **doc.month**.
     * @param data.sse `1`: display results during calculation
     * `0`: display results after all data has been calculated (can take quite a lot of time).
     * @param data.threshold Determines which periods are included in the results. It signifies the percentage above the average size, acting as a **limit**. When relative frequency (rel_frq) surpasses this limit, it is discarded (moved to **removed_freqdist** object).
     * @param data.ctx  **Minus** means **left** context (-1<0). **Plus** means **right** context (6>0).
     *
     *
     * **Positions can be referenced as follows:**
     *
     * `integer number` - where **0** is the first token, **-1** the rightmost token in the left context etc.
     *
     * `1:x` - where **x** is one of the corpus structures (e.g. “doc” or “s” if the corpus has the particular markup). Its meaning is the first token in the structure, except when it is the right boundary of a range - then it is the last token in the structure. Also, other numbers can be used, e.g. -2:x, 3:x, etc. (-1 is the same as 1 with meaning “structure containing searched word”)
     *
     * `a<0` - where **a** stands for a position reference as described in the first two points with meaning '**a** positions before/after the first searched word position' (so this is equivalent to **a**)
     *
     * `a>0` - where **a** stands for the same position reference with meaning 'positions before/after the last searched word position'
     *
     * in the previous two points, if **0** is substituted with a natural number **k**, it means 'before/after **k**-th collocation' instead of 'before/after KWIC'. Collocations are special token groups in the context, that can be added using positive filters (see below).
     *
     *
     * `Ranges` can be referenced as a~b where **a**, **b** stand for token identifiers as above. Examples of positions and ranges:
     *
     * `-1<0` - rightmost token in the left context
     *
     * `3>0` - third token in right context
     *
     * `0>0` - last token
     *
     * `0<0` - first token
     *
     * `0<0~0>0` - range
     *
     * `-1<0~1>0` - range with one token from the left context and one from the right context
     *
     * `1:s` - first token in the sentence containing searched word (or its first token)
     *
     * `1:s>0` - first token in the sentence containing searched word (or its last token)
     *
     * `0<1` - first token of the first-added collocation.
     *
     *
     * `Examples:`
     *
     * sword/ **1>0~3>0**
     *
     * sword/ **1>0~3>0**
     *
     * slemma/ **0<0~0>0**
     *
     * sword/i **-1**
     *
     * sword/ **0**
     *
     * word/ir **-1<0**
     *
     * tag/r **-2<0**
     *
     *
     * @param data.wordlist A wordlist of words for which the relative frequency should be counted. No exact example is here because it is already set in `JSON` parameter.\Example: ['the','a','lion'].
     * @param data.json An optinal way of **wraping parameters**. It is possible to send all relevant parametres via this parameter only. It is classic JSON format.
     *
     * `wordlist`: words for which the relative frequency should be counted.
     *
     *
     * @returns _freqdist `OK`
     * @throws ApiError
     */
    public static getFreqDist(data: GetFreqDistData): CancelablePromise<GetFreqDistResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/freqdist',
            query: {
                corpname: data.corpname,
                wlattr: data.wlattr,
                diaattr: data.diaattr,
                sse: data.sse,
                threshold: data.threshold,
                ctx: data.ctx,
                wordlist: data.wordlist,
                json: data.json
            }
        });
    }
    
    /**
     * Computes collocation candidates from a concordance.
     * -
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.q The CQL query. Regexes are supported for `lemma`, `phrase` and `word` types. The `iquery` supports simplified wildcards (see concordance_query[iquery]). If you decide to use the concordance_query in a json parameter, you do not have to use this parameter.
     * @param data.usesubcorp The name of the `subcorpus`. The `default` value `empty string` refers to the entire corpus. An example for `preloaded/bnc2_tt21` can be `Written Academic` or `1960-1974`.
     * @param data.cattr The (positional attribute)[https://www.sketchengine.eu/my_keywords/positional-attribute/] (lemma, word form etc.) used in the computation.
     * @param data.csortfn Function according to which the result is sorted.
     * @param data.cbgrfns Defines the types of statistics (association measures) to be computed.
     *
     * `t` -> T-score
     *
     * `m` -> MI
     *
     * `3` -> MI3
     *
     * `l` -> log likelihood
     *
     * `s` -> min. sensitivity
     *
     * `p` -> MI.log_f
     *
     * `r` -> relative freq.
     *
     * `f` -> absolute freq.
     *
     * `d` -> logDice.
     *
     * To send one value just type the value for example `t`. If you need to send more values write it as `["t","m","d","3","l","s","p"]`.
     * @param data.cfromw The left boundary of the window in which the collocations should be identified. Defined by the token position left or right of KWIC.
     * @param data.ctow The right boundary of the window in which the collocations should be identified. Defined by the token position left or right of KWIC.
     * @param data.cminfreq The minimum frequency of the token in the corpus.
     * @param data.cminbgr The minimum frequency of the token in the window defined by `cfromw` and `ctow`.
     * @param data.cmaxitems Sets the maximum number of items in the response.
     * @param data.json An optinal way of **wraping parameters**. It is possible to send all relevant parametres via this parameter only. It is classic JSON format.
     *
     * The most frequent uses are:
     *
     * `queryselector`: To select the query type. Supported options are: **cqlrow**, **iqueryrow**, **lemmarow**, **charrow**, **phraserow**, **wordrow**.
     *
     * `iquery`: Use with `iqueryrow`.
     *
     * `cql`: Use with `cqlrow`.
     *
     * `lemma`: Use with `lemmarow`.
     *
     * `lpos`: The part of speech of the lemma.
     *
     * `qmcase`: Sets the attribute to its lowercased version, i.e. the data are extracted from a lowercased version of the corpus. It used for case insensitive analysis. 1 = case sensitive), 0 = lowercased corpus/case insensitive).
     *
     * `char`: Use with charrow.
     *
     * `phrase`: Use with phraserow.
     *
     * `word`: Use with wordrow
     *
     * `cbgrfns`: If you need to send more cbgrfnsDefines the types of statistics (association measures) to be computed. See example.
     * @returns _collx `OK`
     * @throws ApiError
     */
    public static getCollx(data: GetCollxData): CancelablePromise<GetCollxResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/collx',
            query: {
                corpname: data.corpname,
                q: data.q,
                usesubcorp: data.usesubcorp,
                cattr: data.cattr,
                csortfn: data.csortfn,
                cbgrfns: data.cbgrfns,
                cfromw: data.cfromw,
                ctow: data.ctow,
                cminfreq: data.cminfreq,
                cminbgr: data.cminbgr,
                cmaxitems: data.cmaxitems,
                json: data.json
            }
        });
    }
    
    /**
     * Get a list of subcorpora in the corpus or create/delete a subcorpus.
     * There is two option how to create subcorpora in Sketch Engine from `text types` => json parameter (corpus must be annotated for text types) or from `concordances` => q + struct parameters.
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.subcname Name of the subcorpus.
     * @param data.create Set to `1` if new subcorpus should be created. Subcorpus will not be created if left empty (default value == 0).
     * @param data._delete Set to `1` if the corpus should be deleted. Only user subcorpora can be deleted. Nothing will be deleted if left empty (default value == 0).
     * @param data.q Query for creating subcorpora from concordance.
     *
     * The search criteria are specified within brackets following a prefix like `alemma` or `aword`. This prefix often indicates the type of linguistic search (e.g., lemma-based, word-based). The criteria within the brackets can include checks for specific words, lemmas, parts of speech and more, using operators like | (OR), & (AND), and regular expressions.
     *
     * The lists of available attributes, pos tags for specific corpus can be obtained via `/search/corp_info`.
     *
     *
     * `Examples:`
     *
     *
     * - Simple word or lemma search in the BNC corpus:
     *
     * **q=alemma,[lc="test" | lemma_lc="test"]**
     *
     *
     * - Search for nouns with the lemma 'test' in a case-sensitive manner:
     *
     * **q=alemma,[lempos_lc="(test)-n"]**
     *
     *
     * - Search for verbs with the lemma 'test', case-insensitive:
     *
     * **q=alemma,[lempos="(test)-v"]**
     *
     *
     * - Searching for a specific phrase 'test' in a case-sensitive manner:
     *
     * **q=aword,[word="test"]**
     *
     *
     * - Searching for the numeral '1955':
     *
     * **q=alemma,[word="1955" & tag="CD"]**
     *
     *
     * - Regex-based search for words containing the character 'h':
     *
     * **q=alemma,[word=".\*h.\*"]**
     *
     *
     * - Complex search involving the lemma 'book' followed by up to three words, then a verb:
     *
     * **q=alemma,[lemma="book"][]{1,3}[tag="V.\*"]**
     * @param data.struct Which corpus structure should be used in new subcorpus. Used withim concordance type of subcorpus. The lists of structures can be obtained via `/search/corp_info`.
     * @param data.json Used to specify text types for a subcorpus. Takes a JSON object as input, where the key-value pairs define the specific attributes. The attributes can vary depending on the corpus.
     *
     * When using the json parameter in a query, you can define a JSON object with one or more attributes. Each attribute can have a single value or an array of values.
     *
     *
     * The list of available text types for specific corpus can be obtained via `/search/corp_info` just add `sca_` in front the name (see examples).
     *
     *
     * `Examples:`
     *
     *
     * - To create a subcorpus based on a specific spoken text type from the BNC corpus:
     *
     * **{"sca_bncdoc.alltyp":["Spoken context-governed"]}**
     *
     *
     * - To filter texts from the BNC corpus that are both spoken context-governed and spoken demographic:
     *
     * **{"sca_bncdoc.alltyp":["Spoken context-governed","Spoken demographic"]}**
     *
     *
     * - To select texts from the BNC corpus from a specific time period (1960-1974):
     *
     * **{"sca_bncdoc.alltim":["1960-1974"]}**
     *
     *
     * - To create a subcorpus with texts from specific authors and time periods, along with regional specifications:
     *
     * **{"sca_bncdoc.author": ["Author1","Author2",...],"sca_bncdoc.alltim": ["1985-1993","1975-1984"], "sca_bncdoc.wripp": ["UK (unspecific)","Ireland"]}**
     *
     *
     * - To filter texts from the Ententen corpus based on domain and topic:
     *
     * **{"sca_doc.tld":["org","com"], "sca_doc.topic": ["arts","beauty & fashion","cars & bikes","culture & entertainment"]}**
     *
     *
     * - For a user-specific corpus, filtering based on document ID and filename:
     *
     * **{"sca_doc.id":["file29173711"],"sca_doc.filename":["Filename.pdf"]}**
     * @param data.format The `format` of the output. `Empty value` is interpreted as `JSON`. Not every endpoint supports all formats.
     * @returns _subcorp `OK`
     * @throws ApiError
     */
    public static getSubCorp(data: GetSubCorpData): CancelablePromise<GetSubCorpResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/subcorp',
            query: {
                corpname: data.corpname,
                subcname: data.subcname,
                create: data.create,
                delete: data._delete,
                q: data.q,
                struct: data.struct,
                json: data.json,
                format: data.format
            }
        });
    }
    
    /**
     * Rename subcorpus.
     * -
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.subcorpId The name of subcorpus you want to rename.
     * @param data.newSubcorpName A new name for the subcorpus.
     * @returns _subcorpus_rename `OK`
     * @throws ApiError
     */
    public static subcorpusRename(data: SubcorpusRenameData): CancelablePromise<SubcorpusRenameResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/subcorpus_rename',
            query: {
                corpname: data.corpname,
                subcorp_id: data.subcorpId,
                new_subcorp_name: data.newSubcorpName
            }
        });
    }
    
    /**
     * Statistics about the subcorpus.
     * -
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.subcname Name of the subcorpus.
     * @returns _subcorp_info `OK`
     * @throws ApiError
     */
    public static subcorpusInfo(data: SubcorpusInfoData): CancelablePromise<SubcorpusInfoResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/subcorp_info',
            query: {
                corpname: data.corpname,
                subcname: data.subcname
            }
        });
    }
    
    /**
     * Identifies keywords, key n-grams, key collocations and terms.
     * Keywords, key n-grams, key collocations and terms are identified by comparing the focus corpus (or a subcorpus) to a refrence corpus (or a subcorpus). It is the equivalent of using the Keywords and terms tool or using the key option in n-grams or the word sketch.
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.refCorpname Corpus name of the reference corpus, it must have the same processing (the same attributes, the same term grammar).
     * @param data.usesubcorp The name of the `subcorpus`. The `default` value `empty string` refers to the entire corpus. An example for `preloaded/bnc2_tt21` can be `Written Academic` or `1960-1974`.
     * @param data.simpleN The smoothing parameter for (simple maths) [https://www.sketchengine.eu/documentation/simple-maths/].
     * @param data.wlfile Defines the allow list (formerly known as whitelist), the list of words which should be included in the list. See also `wlblacklist`.
     * @param data.wlblacklist A deny list (formerly known as blacklist) is a list of items that should be excluded from the result. The values should be be separated by a newline symbol (without commas between values). In the URL, the newline symbol is `
    `.
     * @param data.attr Switches between the computation of keywords, terms, key n-grams and key collocations. With keywords and n-grams, it also sets the attribute to be used for the computation.
     *
     * For keywords, set to the required attribute, usually `lc`, `word` or `lemma`.
     *
     * For n-grams, set to the required attribute and set `usengrams`, `ngrams_n` and `ngrams_max_n`.
     *
     * For terms, set the attribute to `TERM`.
     *
     * For collocations (word sketch triples, equivalent of using the Word Sketch with AS A LIST option in the web interace), set the attribute to `WSCOLLOC`. Consider using `wlpat`.
     * @param data.alnum Limits the results to items containing only alphanumeric characters.
     * @param data.onealpha Limits the results to items containing at least one alphanumberic character. Words such as 16-year-old or 3D will be included.
     * @param data.minfreq Sets the minimum frequency of the item.
     * @param data.maxfreq Sets the maximum frequency of the item.
     * @param data.maxKeywords
     * @param data.includeNonwords Includes, or excludes, nonwords in the in the result. Nonwords are tokens which do not start with letter of the alphabet (e.g. numbers, punctuation). The regex to match the nonwords is `[^[:alpha:]].*`. Certain specialized corpora may use their own specific definition of nonwords.
     * @param data.icase Switches to the `lc` attribute, i.e. the lower-cased version of the corpus to allow case insensitive searching. `1` means that case sensitivity is off, `0` means it is on.
     * @param data.wlpat Sets a regex to filter the results. Relevant only in a simple wordlist.
     * @param data.addfreqs Represent what kind of frequnecy should be calculated. When used with `reldocf` it is set to `docf` to calculate document frequency.
     * @param data.reldocf Calculate the document frequency for each item in the result. Must be used with `addfreqs` set to `docf`.
     * @param data.usengrams Represent if n-grams should be extracted or just simple keywords.
     * @param data.ngramsN The minimum n-gram length. Usually used with `ngrams_max_n` and `usengrams`.
     * @param data.ngramsMaxN The maximum n-gram length. The maximum is `6`.
     * @param data.format The `format` of the output. `Empty value` is interpreted as `JSON`. Not every endpoint supports all formats.
     * @returns _extract_keywords `OK`
     * @throws ApiError
     */
    public static getExtractKeywords(data: GetExtractKeywordsData): CancelablePromise<GetExtractKeywordsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/extract_keywords',
            query: {
                corpname: data.corpname,
                ref_corpname: data.refCorpname,
                usesubcorp: data.usesubcorp,
                simple_n: data.simpleN,
                wlfile: data.wlfile,
                wlblacklist: data.wlblacklist,
                attr: data.attr,
                alnum: data.alnum,
                onealpha: data.onealpha,
                minfreq: data.minfreq,
                maxfreq: data.maxfreq,
                max_keywords: data.maxKeywords,
                include_nonwords: data.includeNonwords,
                icase: data.icase,
                wlpat: data.wlpat,
                addfreqs: data.addfreqs,
                reldocf: data.reldocf,
                usengrams: data.usengrams,
                ngrams_n: data.ngramsN,
                ngrams_max_n: data.ngramsMaxN,
                format: data.format
            }
        });
    }
    
    /**
     * Returns a list of text types with values.
     * -
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @returns _textypes_with_norms `OK`
     * @throws ApiError
     */
    public static getTextTypesWithNorms(data: GetTextTypesWithNormsData): CancelablePromise<GetTextTypesWithNormsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/textypes_with_norms',
            query: {
                corpname: data.corpname
            }
        });
    }
    
    /**
     * Utility for web interface only. A list of values for a given structure attribute (avattr).
     * Not to be used outside the web interface. Replaced by a more powerful wordlist.
     * @param data The data for the request.
     * @param data.corpname Corpus name. To query your own corpus (e.g. username john, corpus mycorpus), `use` value `user/john/mycorpus`.
     * @param data.avattr Selects a structure attribute (reffered to as text type in the web interface). Corpora have different numbers structure attributes and their values. You can find them in the response of the `corpus_info` method in `freqttattrs` or `subcorpattrs` keys. Not all of them have attributes to show.
     * @param data.avpat A regex to filter the results. Empty string defaults to `.*` (match everything).
     * @param data.avfrom The starting index from which to return the results.
     * @param data.avmaxitems The number of items to return.
     * @param data.icase Switches to the `lc` attribute, i.e. the lower-cased version of the corpus to allow case insensitive searching. `1` means that case sensitivity is off, `0` means it is on.
     * @param data.format The `format` of the output. `Empty value` is interpreted as `JSON`. Not every endpoint supports all formats.
     * @returns _attr_vals `OK`
     * @throws ApiError
     */
    public static getAttrVals(data: GetAttrValsData): CancelablePromise<GetAttrValsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/search/attr_vals',
            query: {
                corpname: data.corpname,
                avattr: data.avattr,
                avpat: data.avpat,
                avfrom: data.avfrom,
                avmaxitems: data.avmaxitems,
                icase: data.icase,
                format: data.format
            }
        });
    }
    
}

export class CorporaService {
    /**
     * Returns a list of all corpora accessible to you.
     * -
     * @returns unknown `OK`
     * @throws ApiError
     */
    public static getCorpora(): CancelablePromise<GetCorporaResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/corpora'
        });
    }
    
    /**
     * Creates a new user corpus.
     * Creates a new empty corpus. Use **Documents** endpoints (and optionally **Filesets**) to add data to the corpus.
     * @param data The data for the request.
     * @param data.requestBody Set the language, corpus name and corpus description.
     *
     * - `info` => The additional information for a newly created corpus. (string)
     *
     * - `language_id` => Language iso-code. `ISO 639-1`. (string)
     *
     * - `name` => Unique `corpus name` for a newly created corpus. (string)
     * @returns unknown `Created`
     * @throws ApiError
     */
    public static createCorpus(data: CreateCorpusData): CancelablePromise<CreateCorpusResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora',
            body: data.requestBody,
            mediaType: 'application/json'
        });
    }
    
    /**
     * Retrieves a user corpus.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @returns _corpora_single `OK`
     * @throws ApiError
     */
    public static getCorpus(data: GetCorpusData): CancelablePromise<GetCorpusResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/corpora/{corpusId}',
            path: {
                corpusId: data.corpusId
            },
            errors: {
                403: '\`Forbidden\`',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Updates a user corpus.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.requestBody  - `expert_mode` => Set to **True** if you are hard-core. (boolean)
     *
     * - `name` => Corpus name. **Given by user**. (string)
     *
     * - `info` => Additional info about corpus. (string)
     *
     * - `document_order` => Can be set to enforce document order within the corpus. (list of integers)
     *
     * - `structures` => Available structures or tags in the corpus. Structures like **s** (sentence), **g** (glue), **doc** (document).(list)
     *
     * - `name` => Structure name. Example: **s**. (string)
     *
     * - `attributes` => A list of used attributes in corpus. (list)
     *
     * - `name` => The name of used attribute. (string)
     *
     * - `file_structure` => The structure in which individual documents should be wrapped. Usually **doc**. (string)
     *
     * - `onion_structure` => The structure for deduplication. Usually **p** (paragraph) or **Null** (no deduplication). (string)
     *
     * - `docstructure` => Structure in which individual documents should be wrapped. Usually **doc**. (string)
     *
     * - `sketch_grammar_id` => Name of sketch grammar file. For sketch grammars querying. Sketch grammar is a series of rules written in the CQL query  language that search for collocations in a text corpus and categorize them according to their  grammatical relations. Example: **preloaded/english-penn_tt-3.3.wsdef.m4**. (string)
     *
     * - `term_grammar_ir` => Name of term grammar file. Term grammar tells Sketch Engine which words and phrases should indentify as terms. Example: **corpora/wsdef/english-penn_tt-terms-3.1.termdef.m4**. (string)
     * @returns unknown `OK`
     * @throws ApiError
     */
    public static updateCorpus(data: UpdateCorpusData): CancelablePromise<UpdateCorpusResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/ca/api/corpora/{corpusId}',
            path: {
                corpusId: data.corpusId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                403: '\`Forbidden\`',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Deletes a user corpus.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @returns void `No Content`
     * @throws ApiError
     */
    public static deleteCorpus(data: DeleteCorpusData): CancelablePromise<DeleteCorpusResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/ca/api/corpora/{corpusId}',
            path: {
                corpusId: data.corpusId
            },
            errors: {
                403: '\`Forbidden\`',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Checks if the corpus fulfills all conditions to be compiled. (RPC)
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.requestBody  In this documentation, an empty request is used mostly used with the **RPC style** method where the content in a request is not needed (in most cases). RPC style endpoints focus on performing **one action** right (procedures, command) easier than **REST API**-based endpoints. It is not as scalable as REST API style. RPC is mostly used with HTTP: GET (to fetch information) and POST (to everything else) in CA api is it used with POST HTTP method.
     * @returns _can_be_compiled `OK`
     * @throws ApiError
     */
    public static checkCompilable(data: CheckCompilableData): CancelablePromise<CheckCompilableResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/can_be_compiled',
            path: {
                corpusId: data.corpusId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\`',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Retrieves the current progress of the corpus compilation. (RPC)
     * -
     * @param data The data for the request.
     * @param data.requestBody  In this documentation, an empty request is used mostly used with the **RPC style** method where the content in a request is not needed (in most cases). RPC style endpoints focus on performing **one action** right (procedures, command) easier than **REST API**-based endpoints. It is not as scalable as REST API style. RPC is mostly used with HTTP: GET (to fetch information) and POST (to everything else) in CA api is it used with POST HTTP method.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @returns _get_progress `OK`
     * @throws ApiError
     */
    public static getCompilationProgress(data: GetCompilationProgressData): CancelablePromise<GetCompilationProgressResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/get_progress',
            path: {
                corpusId: data.corpusId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                403: '\`Forbidden\`',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Performs the corpus compilation. (RPC)
     * -
     * @param data The data for the request.
     * @param data.requestBody  `Structures` or `structure attributes` in corpus which should be compiled. Usually: `all`. (string)
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @returns _rpc_style `OK`
     * @throws ApiError
     */
    public static compileCorpus(data: CompileCorpusData): CancelablePromise<CompileCorpusResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/compile',
            path: {
                corpusId: data.corpusId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: '\`Bad Request\`',
                401: '\`Unauthorized\`',
                403: '\`Forbidden\`',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Show the compilation log file '.log' of the corpus.
     * If **logName** == **last.log** it shows the latest version of the log file.
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.logName Name of log file. Name 'last.log' show the newest log for that corpus.
     * @returns string `OK`
     * @throws ApiError
     */
    public static getCompilationLog(data: GetCompilationLogData): CancelablePromise<GetCompilationLogResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/corpora/{corpusId}/logs/{logName}',
            path: {
                corpusId: data.corpusId,
                logName: data.logName
            },
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need \`read\` permission)',
                404: '\`Not Found\`',
                405: '\`Method Not Allowed\`'
            }
        });
    }
    
    /**
     * Downloads the documents from which the corpus was created (the source files).
     * Example call can be: **https://app.sketchengine.eu/ca/api/corpora/{corpusId}/download?format=vert&file_structure=doc**.
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.format File format in which the corpus should be downloaded. Just three formats are supported.
     * @param data.fileStructure The contents of each file will be enclosed in a XML like structure of the specified name with the filename as its id attribute and the URL (if available) as the url attribute. If empty document boundaries will be lost. Example: `doc`.
     * @param data.aligned Required when you want to download parallel corpora, **when format == tmx.** Specify aligned corpus name.
     * @returns string `OK`
     * @throws ApiError
     */
    public static getCorpusSource(data: GetCorpusSourceData): CancelablePromise<GetCorpusSourceResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/corpora/{corpusId}/download',
            path: {
                corpusId: data.corpusId
            },
            query: {
                format: data.format,
                file_structure: data.fileStructure,
                aligned: data.aligned
            },
            errors: {
                400: '\`Bad Request\` Examples: \`ALIGNED_NOT_FOUND\`, \`ALIGNED_FORBIDDEN\`, \`INVALID_FORMAT\`.',
                401: '\`Unauthorized\`',
                403: '\`Forbidden\`',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Cancels running tasks (e.g. compilation) relatated to the corpus. (RPC)
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.requestBody  In this documentation, an empty request is used mostly used with the **RPC style** method where the content in a request is not needed (in most cases). RPC style endpoints focus on performing **one action** right (procedures, command) easier than **REST API**-based endpoints. It is not as scalable as REST API style. RPC is mostly used with HTTP: GET (to fetch information) and POST (to everything else) in CA api is it used with POST HTTP method.
     * @returns _rpc_style `OK`
     * @throws ApiError
     */
    public static cancelJob(data: CancelJobData): CancelablePromise<CancelJobResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/cancel_job',
            path: {
                corpusId: data.corpusId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\`'
            }
        });
    }
    
    /**
     * Compiles a parallel corpus (consisting of two or more aligned corpora). (RPC)
     * -
     * @param data The data for the request.
     * @param data.requestBody List of corpus IDs used in aligned compilation.
     *
     * - `corpus_ids` => A list of **Corpus ID** of multilingual corpora. (integer)
     *
     * - `structures` => Represent if **all** structures should be used during compilation (in that case it should be contain just **all**) or just some of them. (string)
     * @returns _rpc_style `OK`
     * @throws ApiError
     */
    public static compileAlignedCorpus(data: CompileAlignedCorpusData = {}): CancelablePromise<CompileAlignedCorpusResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/compile_aligned',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: '\`Bad Request\`',
                403: '\`Forbidden\`'
            }
        });
    }
    
    /**
     * Creates segment representing the same line in two languages in a parallel corpus. (RPC)
     * Run if documents inserted into the corpus are not aligned.
     * @param data The data for the request.
     * @param data.requestBody - `alignstruct` => According to which structure the document should be aligned. Usually, **\<s>**. (string)
     *
     * - `auto` => **True**, when documents are not compiled. Sketch Engine will align them automatically. (boolean)
     *
     * - `corpus_ids` => A list of **Corpus ID** of multilingual corpus. (integer)
     * @returns _rpc_style `OK`
     * @throws ApiError
     */
    public static segmentAlign(data: SegmentAlignData = {}): CancelablePromise<SegmentAlignResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/align',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: '\`Bad Request\`',
                401: '\`Unauthorized\`',
                403: '\`Forbidden\`'
            }
        });
    }
    
}

export class DocumentsService {
    /**
     * Retrieves a list of all documents in the corpus.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.filesetId ID of file subdirectory. **0** stands for default document directory with name `upload`.
     * @returns _documents_get `OK`
     * @throws ApiError
     */
    public static getAllDocuments(data: GetAllDocumentsData): CancelablePromise<GetAllDocumentsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/corpora/{corpusId}/documents',
            path: {
                corpusId: data.corpusId
            },
            query: {
                fileset_id: data.filesetId
            },
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need \`view\` permission).',
                404: '\`Not Found\` (HTML response).'
            }
        });
    }
    
    /**
     * Uploads a new document.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.filesetId ID of file subdirectory. **0** stands for default document directory with name `upload`.
     * @param data.waitWithTagging Delay tagging by given number of `seconds`.
     * @param data.formData File to upload.
     * @returns _documents_post `Created`
     * @throws ApiError
     */
    public static createNewDocument(data: CreateNewDocumentData): CancelablePromise<CreateNewDocumentResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/documents',
            path: {
                corpusId: data.corpusId
            },
            query: {
                fileset_id: data.filesetId,
                wait_with_tagging: data.waitWithTagging
            },
            formData: data.formData,
            mediaType: 'multipart/form-data',
            errors: {
                400: '\`Bad Request\`',
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need \`upload\` permission).',
                404: '\`Not Found\` (HTML response).'
            }
        });
    }
    
    /**
     * Edits the metadata of a document.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.requestBody   - `id` => Unique numeric `document ID`. (integer)
     *
     * - `metadata` => Pairs of `attribute_name`:`value`.
     * @param data.filesetId ID of file subdirectory. **0** stands for default document directory with name `upload`.
     * @returns _documents_get `OK`
     * @throws ApiError
     */
    public static updateDocumentMetadata(data: UpdateDocumentMetadataData): CancelablePromise<UpdateDocumentMetadataResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/ca/api/corpora/{corpusId}/documents',
            path: {
                corpusId: data.corpusId
            },
            query: {
                fileset_id: data.filesetId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: '\`Bad Request\`',
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need \`edit\` permission).',
                404: '\`Not Found\` (HTML response).'
            }
        });
    }
    
    /**
     * Retrieves a specific document.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.documentId Document ID. For document querying.
     * @returns _documents_get `OK`
     * @throws ApiError
     */
    public static getDocument(data: GetDocumentData): CancelablePromise<GetDocumentResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/corpora/{corpusId}/documents/{documentId}',
            path: {
                corpusId: data.corpusId,
                documentId: data.documentId
            },
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need \`view\` permission).',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Updates documents to corpus.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.documentId Document ID. For document querying.
     * @param data.requestBody  - `filename_display` => Name of documents. (string)
     *
     * - `id` => Unique numeric **document ID** to identify individual documents. (integer)
     *
     * - `inProgress` => Represents whether the currently edited document is in use. (boolean)
     *
     * - `isArchive` => Represents if the updated document is in a format like .zip (created via some archive manager). (boolean)
     *
     * - `metadata` => Metadata of document. For example, additional attributes and values.
     *
     * - `parameters` => Parameters for plaintext extraction.
     *
     * - `encoding` => Encoding standard of the document. Usually, **UTF-8**. (string)
     *
     * - `justext_stoplist` => Represent the list of unimportant words, in a specified language, from an NLP point of view. (string)
     *
     * - `permutation` => Changing the order of columns (applies only to **type=vert**). (integer)
     *
     * - `tmx_lang` => TMX (translation memory exchange). Language of document used for parallel corpus creation. (string)
     *
     * - `tmx_struct` => Alignment structure to be used for multilingual documents, **align** is the most used structure. Used within segment distinction, which sentence is in which language and to put sentences with the same meaning into one segment. (string)
     *
     * - `tmx_untranslated` => Placeholder for empty segments in multilingual documents. The segments which have no counterpart in a second language of parallel corpus. (string)
     *
     * - `type` => File format (.csv, .doc, .docx, .htm, .html). (string)
     *
     * - `unlegalese` => Convert **all-caps** text to **normal case**. (boolean)
     *
     * - `temporary` => Is document temporary or not. (boolean)
     *
     * - `word_count` => Total number of **words** (tokens minus punctuation etc.) in document. (integer)
     *
     * - `vertical_progress` => Progress of **vertical file** creation. (integer)
     *
     * - `vertical_error` => An error occured while creating the vertical file. If the creation was succesfull the value is **Null**. (string)
     * @returns _documents_get `OK`
     * @throws ApiError
     */
    public static updateDocument(data: UpdateDocumentData): CancelablePromise<UpdateDocumentResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/ca/api/corpora/{corpusId}/documents/{documentId}',
            path: {
                corpusId: data.corpusId,
                documentId: data.documentId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: '\`Bad Request\`',
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need \`edit\` permission).',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Deletes one or more documents from the corpus.
     * To delete more documents, separate document ids with commas. Example call: `https://app.sketchengine.eu/ca/api/corpora/{corpusId}/documents/{documentId_1},{documentId_2}`
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.documentId Document ID. For document querying.
     * @returns void `No Content`
     * @throws ApiError
     */
    public static deleteDocuments(data: DeleteDocumentsData): CancelablePromise<DeleteDocumentsResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/ca/api/corpora/{corpusId}/documents/{documentId}',
            path: {
                corpusId: data.corpusId,
                documentId: data.documentId
            },
            errors: {
                400: '\`Bad Request\`',
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need \`delete\` permission).',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Updates document parameters. (RPC)
     * Updates parameters like: `File Type`, `Encoding`, etc.
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.documentId Document ID. For document querying.
     * @param data.requestBody  - `auto_paragraphs` => Automatically insert paragraph breaks (**\<p>**) in place of blank lines. (string)
     *
     * - `encoding` => Encoding standard of the document. Usually **UTF-8**. (string)
     *
     * - `justext_stoplist` => Represent the list of unimportant words, in a specified language, from an NLP point of view. (string)
     *
     * - `permutation` => Changing the order of columns (applies only to **type=vert**).
     *
     * - `tmx_lang` => TMX (translation memory exchange). Language of document used for parallel corpus creation. (string)
     *
     * - `tmx_struct` => Alignment structure to be used for multilingual documents, **align** is the most used structure. Used within segment distinction, which sentence is in which language and to put sentences with the same meaning into one segment. (string)
     *
     * - `tmx_untranslated` => Placeholder for empty segments in multilingual documents. The segments which have no counterpart in a second language of parallel corpus. (string)
     *
     * - `type` => File format (.csv, .doc, .docx, .htm, .html). (string)
     *
     * - `unlegalese` => Convert **all-caps** text to **normal case**. (boolean)
     * @returns _doc_preview `OK`
     * @throws ApiError
     */
    public static updateDocumentParameters(data: UpdateDocumentParametersData): CancelablePromise<UpdateDocumentParametersResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/documents/{documentId}/preview',
            path: {
                corpusId: data.corpusId,
                documentId: data.documentId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                403: '\`Forbidden\`'
            }
        });
    }
    
    /**
     * Downloads a corpus file in its original format (the format that was uploaded). This method cannot be simulated in this online documentation.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.documentId Document ID. For document querying.
     * @returns binary `OK`
     * @throws ApiError
     */
    public static getDocumentOriginal(data: GetDocumentOriginalData): CancelablePromise<GetDocumentOriginalResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/corpora/{corpusId}/documents/{documentId}/original',
            path: {
                corpusId: data.corpusId,
                documentId: data.documentId
            },
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need \`view\` permission).',
                404: '\`Not Found\` (Html response).',
                405: '\`Method Not Allowed\`'
            }
        });
    }
    
    /**
     * Retrieves 1KB of data in plaintext format. Can load more than 1KB.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.documentId Document ID. For document querying.
     * @returns string `Partial Content`
     * @throws ApiError
     */
    public static getDocumentPlaintext(data: GetDocumentPlaintextData): CancelablePromise<GetDocumentPlaintextResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/corpora/{corpusId}/documents/{documentId}/plaintext',
            path: {
                corpusId: data.corpusId,
                documentId: data.documentId
            },
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need \`view\` permission).',
                404: '\`Not Found\` (Html response).',
                405: '\`Method Not Allowed\`',
                416: '\`Range Not Satisfiable\`'
            }
        });
    }
    
    /**
     * Retrieves 1KB of data in vertical format. Can load more than 1KB.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.documentId Document ID. For document querying.
     * @returns string `Partial Content`
     * @throws ApiError
     */
    public static getDocumentVertical(data: GetDocumentVerticalData): CancelablePromise<GetDocumentVerticalResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/corpora/{corpusId}/documents/{documentId}/vertical',
            path: {
                corpusId: data.corpusId,
                documentId: data.documentId
            },
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\`',
                404: '\`Not Found\` (Html response).',
                405: '\`Method Not Allowed\`',
                416: '\`Range Not Satisfiable\`'
            }
        });
    }
    
    /**
     * Expands a ZIP file. (if the corpus files were uploaded as a zip archive). Expanding is not necessary for the corpus to work.(RPC)
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.documentId Document ID. For document querying.
     * @param data.requestBody  In this documentation, an empty request is used mostly used with the **RPC style** method where the content in a request is not needed (in most cases). RPC style endpoints focus on performing **one action** right (procedures, command) easier than **REST API**-based endpoints. It is not as scalable as REST API style. RPC is mostly used with HTTP: GET (to fetch information) and POST (to everything else) in CA api is it used with POST HTTP method.
     * @returns _rpc_expand_archive `OK`
     * @throws ApiError
     */
    public static expandArchive(data: ExpandArchiveData): CancelablePromise<ExpandArchiveResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/documents/{documentId}/expand_archive',
            path: {
                corpusId: data.corpusId,
                documentId: data.documentId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: '\`Bad Request\`',
                403: '\`Forbidden (you need edit permission)\`',
                404: '\`Not Found\` (Html response).'
            }
        });
    }
    
    /**
     * Cancels running task which is in direct relation to the document. (RPC)
     * An example task that can be canceled is `uploading file`.
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.documentId Document ID. For document querying.
     * @param data.requestBody  In this documentation, an empty request is used mostly used with the **RPC style** method where the content in a request is not needed (in most cases). RPC style endpoints focus on performing **one action** right (procedures, command) easier than **REST API**-based endpoints. It is not as scalable as REST API style. RPC is mostly used with HTTP: GET (to fetch information) and POST (to everything else) in CA api is it used with POST HTTP method.
     * @returns _rpc_style `OK`
     * @throws ApiError
     */
    public static cancelDocumentJob(data: CancelDocumentJobData): CancelablePromise<CancelDocumentJobResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/documents/{documentId}/cancel_job',
            path: {
                corpusId: data.corpusId,
                documentId: data.documentId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                403: '\`Forbidden\` (you need \`edit\` permission).',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Shows the actual progress of the currently running task related to documents. (RPC)
     * Used in tasks like `uploading` new files which will be used to create or expand the corpora.
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.documentId Document ID. For document querying.
     * @param data.requestBody  In this documentation, an empty request is used mostly used with the **RPC style** method where the content in a request is not needed (in most cases). RPC style endpoints focus on performing **one action** right (procedures, command) easier than **REST API**-based endpoints. It is not as scalable as REST API style. RPC is mostly used with HTTP: GET (to fetch information) and POST (to everything else) in CA api is it used with POST HTTP method.
     * @returns _get_progress `OK`
     * @throws ApiError
     */
    public static getProgress(data: GetProgressData): CancelablePromise<GetProgressResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/documents/{documentId}/get_progress',
            path: {
                corpusId: data.corpusId,
                documentId: data.documentId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                403: '\`Forbidden\` (you need permission to \`view\` to the specified corpus).',
                404: '\`Not Found\`'
            }
        });
    }
    
}

export class FilesetsService {
    /**
     * List of "subdirectories", i.e. unzipped archives or WebBootCaT runs for a given corpus.
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.compileWhenFinished Start corpus compiling after web-crawler finishes downloading content from the internet.
     * @returns unknown `OK`
     * @throws ApiError
     */
    public static getFileSets(data: GetFileSetsData): CancelablePromise<GetFileSetsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/corpora/{corpusId}/filesets',
            path: {
                corpusId: data.corpusId
            },
            query: {
                compile_when_finished: data.compileWhenFinished
            },
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need permission to \`upload\` to the specified corpus).',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Creates new fileset by the web-crawler.
     * Used within creating or expanding corpus.
     * @param data The data for the request.
     * @param data.requestBody Setting parameters to improve web-crawler accuracy.
     *
     * - `bl_max_total_kw` => **Blacklist max total keyword**. Means that web page or document will be discarded if it contains more words from the denylist (blacklist) than this limit. (integer)
     *
     * - `bl_max_unique_kw` => **Blacklist max unique keyword**. Means that web page or document will be discarded if it contains more unique words from the denylist (blacklist) than this limit. (integer)
     *
     * - `black_list` => A list (separated by whitespaces) of **blocked words**, words you don't want to see in your future corpus. (string)
     *
     * - `input_type` => Input types the web-crawler will works with. Example: **urls**. (string)
     *
     * - `max_cleaned_file_size` => Web pages and documents with a size **over** this limit (**in kB**) will be ignored. (integer)
     *
     * - `max_file_size` => Web pages and documents with a size **over** this limit (**in kB**) will be ignored. (integer)
     *
     * - `min_cleaned_file_size` => Web pages and documents **smaller** than this limit (**in kB**) after cleaning will be ignored. Cleaning involves conversion to plain text, removing boilerplate text (e.g. navigation menus, legal text, disclaimers and other repetitive content). (integer)
     *
     * - `min_file_size` => Web pages and documents with a **size below** this limit (**in kB**) will be ignored. (integer)
     *
     * - `name` => Texts will be organized into a corpus folder with this name. (string)
     *
     * - `seed_word` => A list of words according to which the URLs were chosen to be searched. (string)
     *
     * - `white_list` => A list (separated by whitespaces) of allowed words, words you want to see in your future corpus. (list of string)
     *
     * - `wl_min_kw_ratio` => **Whitelist minimal keywords ratio**. Means that web page or document will be included only if the percentage of allowlist words compared to total words is higher than this limit. (integer)
     *
     * - `wl_min_total_kw` => **Whitelist minimal total keywords**. Means that web page or document will be included only if it contains more words from the allowlist (whitelist) than this limit. (integer)
     *
     * - `wl_min_unique_kw` => **Whitelist minimal unique keywords**. Means that a web page or document will be included only if it contains more words from the allowlist (whitelist) than this limit. (integer)
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.compileWhenFinished Start corpus compiling after web-crawler finishes downloading content from the internet.
     * @returns unknown `Created`
     * @throws ApiError
     */
    public static createFileSet(data: CreateFileSetData): CancelablePromise<CreateFileSetResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/filesets',
            path: {
                corpusId: data.corpusId
            },
            query: {
                compile_when_finished: data.compileWhenFinished
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: '\`Bad Request\`',
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need permission to \`upload\` to the specified corpus).',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Returns information about a specific "subdirectory".
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.filesetId ID of file subdirectories. If sets to 0 it will return top-level folder of documents, so if you have a web corpora with folders web1 and web2 it will return web1.
     * @returns unknown `OK`
     * @throws ApiError
     */
    public static getFileSet(data: GetFileSetData): CancelablePromise<GetFileSetResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/corpora/{corpusId}/filesets/{filesetId}',
            path: {
                corpusId: data.corpusId,
                filesetId: data.filesetId
            },
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need permission to \`view\`).',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Deletes subdirectory containing document (for creating corpus).
     * -
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.filesetId ID of file subdirectories. If sets to 0 it will return top-level folder of documents, so if you have a web corpora with folders web1 and web2 it will return web1.
     * @returns void `No Content`
     * @throws ApiError
     */
    public static deleteFileSet(data: DeleteFileSetData): CancelablePromise<DeleteFileSetResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/ca/api/corpora/{corpusId}/filesets/{filesetId}',
            path: {
                corpusId: data.corpusId,
                filesetId: data.filesetId
            },
            errors: {
                400: '\`Bad Request\`',
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need permission to \`delete\`).',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Cancel running task. (RPC)
     * Example: cancel downloading data from websites by web-crawler.
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.filesetId ID of file subdirectories. If sets to 0 it will return top-level folder of documents, so if you have a web corpora with folders web1 and web2 it will return web1.
     * @param data.requestBody  In this documentation, an empty request is used mostly used with the **RPC style** method where the content in a request is not needed (in most cases). RPC style endpoints focus on performing **one action** right (procedures, command) easier than **REST API**-based endpoints. It is not as scalable as REST API style. RPC is mostly used with HTTP: GET (to fetch information) and POST (to everything else) in CA api is it used with POST HTTP method.
     * @returns _rpc_style `OK`
     * @throws ApiError
     */
    public static cancelFileSetJob(data: CancelFileSetJobData): CancelablePromise<CancelFileSetJobResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/filesets/{filesetId}/cancel_job',
            path: {
                corpusId: data.corpusId,
                filesetId: data.filesetId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need \`upload\` permission).',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Shows the actual progress of a running task related to filesets. (RPC)
     * A task like `downloading content from web` to create corpus with web crawler.
     * @param data The data for the request.
     * @param data.corpusId Numeric corpus ID. For corpora querying.
     * @param data.filesetId ID of file subdirectories. If sets to 0 it will return top-level folder of documents, so if you have a web corpora with folders web1 and web2 it will return web1.
     * @param data.requestBody  In this documentation, an empty request is used mostly used with the **RPC style** method where the content in a request is not needed (in most cases). RPC style endpoints focus on performing **one action** right (procedures, command) easier than **REST API**-based endpoints. It is not as scalable as REST API style. RPC is mostly used with HTTP: GET (to fetch information) and POST (to everything else) in CA api is it used with POST HTTP method.
     * @returns _filesets_get_progress `OK`
     * @throws ApiError
     */
    public static getFileSetProgress(data: GetFileSetProgressData): CancelablePromise<GetFileSetProgressResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/corpora/{corpusId}/filesets/{filesetId}/get_progress',
            path: {
                corpusId: data.corpusId,
                filesetId: data.filesetId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                403: '\`Forbidden\` (you need \`view\` permission).',
                404: '\`Not Found\`'
            }
        });
    }
    
}

export class LanguagesService {
    /**
     * Retrieves a list of all languages.
     * -
     * @returns unknown `OK`
     * @throws ApiError
     */
    public static getLanguages(): CancelablePromise<GetLanguagesResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/languages'
        });
    }
    
}

export class SomefilesService {
    /**
     * Upload aligned documents for creating parallel corpus.
     * -
     * @param data The data for the request.
     * @param data.requestBody Aligned multilingual file (mostly in '.tmx' file type).
     * @returns _somefiles_post `Created`
     * @throws ApiError
     */
    public static uploadAligendDocuments(data: UploadAligendDocumentsData = {}): CancelablePromise<UploadAligendDocumentsResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/somefiles',
            body: data.requestBody,
            mediaType: 'multipart/form-data; boundary={boundary}',
            errors: {
                400: '\`Bad Request\`'
            }
        });
    }
    
    /**
     * Retrieves specific multilingual file metadata.
     * -
     * @param data The data for the request.
     * @param data.somefileId Alphanumeric multilanguage file ID
     * @returns _somefiles_post `OK`
     * @throws ApiError
     */
    public static getAlignedDocuments(data: GetAlignedDocumentsData): CancelablePromise<GetAlignedDocumentsResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/somefiles/{somefileId}',
            path: {
                somefileId: data.somefileId
            },
            errors: {
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Updates multilingual file metadata.
     * -
     * @param data The data for the request.
     * @param data.somefileId Alphanumeric multilanguage file ID
     * @param data.requestBody  - `corpora`
     *
     * - `guessed_language_code`
     *
     * - `language_id` => Language iso-code. **ISO 639-1**. (string)
     *
     * - `name` => Language name in **English**. (string)
     * @returns unknown `OK`
     * @throws ApiError
     */
    public static updateAlignedDocs(data: UpdateAlignedDocsData): CancelablePromise<UpdateAlignedDocsResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/ca/api/somefiles/{somefileId}',
            path: {
                somefileId: data.somefileId
            },
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                400: '\`Bad Request\`',
                404: '\`Not Found\`'
            }
        });
    }
    
}

export class TemplatesService {
    /**
     * Retrieves details of specified user template / tagset.
     * -
     * @param data The data for the request.
     * @param data.templateId Numerical template ID, but preloaded templates do not have ID but you can query them by their name. Example: `UNIVERSAL_3`.
     * @returns _template `OK`
     * @throws ApiError
     */
    public static getUserTemplate(data: GetUserTemplateData): CancelablePromise<GetUserTemplateResponse> {
        return __request(OpenAPI, {
            method: 'GET',
            url: '/ca/api/tagsets/{templateId}',
            path: {
                templateId: data.templateId
            },
            errors: {
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need permission to \`read\`).',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Updates specified user template/tagset.
     * -
     * @param data The data for the request.
     * @param data.templateId Numerical template ID, but preloaded templates do not have ID but you can query them by their name. Example: `UNIVERSAL_3`.
     * @param data.requestBody  - `id` => Alphanumeric **template/tagset ID**. The terms **tagset** and **templates** are interchangeable. (string)
     *
     * - `name` => Name of **template/tagset** file. (string)
     *
     * - `owner_id` => Unique numeric owner ID (usually you). If tagset/template is preloaded Null. (integer)
     *
     * - `owner_name` => Tagset/template owner name (usually you). If tagset/template is preloaded Null. (string)
     *
     * - `has_pipeline` => Vertical creation is supported. False for legacy templates. (boolean)
     *
     * - `has_tags` => Morphological tagging is supported. (boolean)
     *
     * - `has_lemmas` => Lemmatization is supported. (boolean)
     *
     * - `static_attributes` => A list of attributes which can appear in corpus.
     *
     * - `structures` => A list of used structures. Examples \<s>, \<g>.
     *
     * - `tagsetdoc` => URL leading to template/tagset documentation. (string)
     *
     * - `content` => Content of tagset. (string)
     *
     * - `default_sketchgrammar_id` => Not ID, as you probably imagine, but filename of preselected sketchgrammar (.m4 format). (string)
     *
     * - `default_termgrammar_id` => Not ID, as you probably imagine, but filename of preselected sketchgrammar (.m4 format). (string)
     *
     * - `sharing` => List.
     *
     * - `users` => The ID of user you share template with.
     *
     * - `id` => The ID of group you share template with.
     * @returns unknown `OK`
     * @throws ApiError
     */
    public static updateUserTemplate(data: UpdateUserTemplateData): CancelablePromise<UpdateUserTemplateResponse> {
        return __request(OpenAPI, {
            method: 'PUT',
            url: '/ca/api/tagsets/{templateId}',
            path: {
                templateId: data.templateId
            },
            body: data.requestBody,
            mediaType: 'application/x-www-form-urlencoded; charset=UTF-8',
            errors: {
                400: '\`Bad Request\`',
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need to be \`owner\` of the template).',
                404: '\`Not Found\`'
            }
        });
    }
    
    /**
     * Deletes user template.
     * -
     * @param data The data for the request.
     * @param data.templateId Numerical template ID, but preloaded templates do not have ID but you can query them by their name. Example: `UNIVERSAL_3`.
     * @returns void `No Content`
     * @throws ApiError
     */
    public static deleteUserTemplate(data: DeleteUserTemplateData): CancelablePromise<DeleteUserTemplateResponse> {
        return __request(OpenAPI, {
            method: 'DELETE',
            url: '/ca/api/tagsets/{templateId}',
            path: {
                templateId: data.templateId
            },
            errors: {
                400: '\`Bad Request\`',
                401: '\`Unauthorized\`',
                403: '\`Forbidden\` (you need to be \`owner\` of the template).',
                404: '\`Not Found\`'
            }
        });
    }
    
}

export class UsersService {
    /**
     * Retrieves the user's current word space state (default 1 000 000 words). (RPC)
     * -
     * @param data The data for the request.
     * @param data.requestBody  In this documentation, an empty request is used mostly used with the **RPC style** method where the content in a request is not needed (in most cases). RPC style endpoints focus on performing **one action** right (procedures, command) easier than **REST API**-based endpoints. It is not as scalable as REST API style. RPC is mostly used with HTTP: GET (to fetch information) and POST (to everything else) in CA api is it used with POST HTTP method.
     * @returns _get_used_space `OK`
     * @throws ApiError
     */
    public static getUsedSpace(data: GetUsedSpaceData = {}): CancelablePromise<GetUsedSpaceResponse> {
        return __request(OpenAPI, {
            method: 'POST',
            url: '/ca/api/users/me/get_used_space',
            body: data.requestBody,
            mediaType: 'application/json',
            errors: {
                401: '\`Unauthorized\`'
            }
        });
    }
    
}